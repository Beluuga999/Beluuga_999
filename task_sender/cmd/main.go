package main

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/urfave/cli/v2"
	"github.com/yetanotherco/aligned_layer/common"
	"github.com/yetanotherco/aligned_layer/core/chainio"
	"github.com/yetanotherco/aligned_layer/core/config"
	"github.com/yetanotherco/aligned_layer/task_sender/pkg"
	generateproof "github.com/yetanotherco/aligned_layer/task_sender/test_examples/gnark_groth16_bn254_infinite_script/pkg"
	operator "github.com/yetanotherco/aligned_layer/operator/pkg"
)

var (
	provingSystemFlag = &cli.StringFlag{
		Name:     "proving-system",
		Aliases:  []string{"s"},
		Required: true,
		Usage:    "the `PROVING SYSTEM` to use (e.g., plonk, groth16)",
	}
	proofFlag = &cli.PathFlag{
		Name:     "proof",
		Aliases:  []string{"p"},
		Required: true,
		Usage:    "path to the `PROOF FILE`",
	}
	publicInputFlag = &cli.PathFlag{
		Name:     "public-input",
		Aliases:  []string{"i"},
		Required: true,
		Usage:    "path to the `PUBLIC INPUT FILE`",
	}
	verificationKeyFlag = &cli.PathFlag{
		Name:     "verification-key",
		Aliases:  []string{"v"},
		Required: false,
		Usage:    "path to the `VERIFICATION KEY FILE`",
	}
	intervalFlag = &cli.IntFlag{
		Name:    "interval",
		Aliases: []string{"t"},
		Value:   1,
		Usage:   "the `INTERVAL` in seconds to send tasks",
	}
	feeFlag = &cli.IntFlag{
		Name:     "fee",
		Required: false,
		Value:    1,
		Usage:    "the `FEE` in wei to send when sending a task",
	}

	quorumThresholdFlag = &cli.UintFlag{
		Name:    "quorum-threshold",
		Aliases: []string{"q"},
		Value:   100,
		Usage:   "the `QUORUM THRESHOLD PERCENTAGE` for tasks",
	}
	daFlag = &cli.StringFlag{
		Name: "da",
		// Can be either "eigen" or "celestia"
		Usage: "the `DA` to use (calldata | eigen | celestia)",
		Value: "calldata",
	}
)

var sendTaskFlags = []cli.Flag{
	provingSystemFlag,
	proofFlag,
	publicInputFlag,
	verificationKeyFlag,
	config.ConfigFileFlag,
	feeFlag,
	quorumThresholdFlag,
	daFlag,
}

var loopTasksFlags = []cli.Flag{
	provingSystemFlag,
	proofFlag,
	publicInputFlag,
	verificationKeyFlag,
	config.ConfigFileFlag,
	intervalFlag,
	feeFlag,
	quorumThresholdFlag,
	daFlag,
}

var infiniteTasksFlags = []cli.Flag{
	provingSystemFlag,
	config.ConfigFileFlag,
	intervalFlag,
	feeFlag,
	quorumThresholdFlag,
	daFlag,
}

func main() {
	app := &cli.App{
		Name: "Aligned Layer Task Sender",
		Commands: []*cli.Command{
			{
				Name:        "send-task",
				Usage:       "Send a single task to the verifier",
				Description: "Service that sends proofs to verify by operator nodes.",
				Flags:       sendTaskFlags,
				Action: func(c *cli.Context) error {
					return taskSenderMain(c)
				},
			},
			{
				Name:        "loop-tasks",
				Usage:       "Send a task every `INTERVAL` seconds",
				Description: "Service that sends proofs to verify by operator nodes.",
				Flags:       loopTasksFlags,
				Action:      taskSenderLoopMain,
			},
			{
				Name:        "infinite-tasks",
				Usage:       "Send a different task every `INTERVAL` seconds",
				Description: "Service that sends proofs to verify by operator nodes.",
				Flags:       infiniteTasksFlags,
				Action:      taskSenderInfiniteMain,
			},
		},
	}

	err := app.Run(os.Args)
	if err != nil {
		log.Fatalln("Task sender application failed.", "Message:", err)
	}
}

func taskSenderMain(c *cli.Context, xParam ...int) error {
	x := 0
	if len(xParam) > 0 {
		x = xParam[0]
	}
	taskSenderConfig := config.NewTaskSenderConfig(c.String(config.ConfigFileFlag.Name))
	avsWriter, err := chainio.NewAvsWriterFromConfig(taskSenderConfig.BaseConfig, taskSenderConfig.EcdsaConfig)
	if err != nil {
		return err
	}

	taskSender := pkg.NewTaskSender(taskSenderConfig, avsWriter)

	batchMerkleRoot, batchDataPointer, err := getProofData(c, x)
	if err != nil {
		return err
	}

	task := pkg.NewTask(batchMerkleRoot, batchDataPointer)

	err = taskSender.SendTask(task)
	if err != nil {
		return err
	}

	return nil
}

func getProofData(c *cli.Context, x int) ([32]byte, string, error) {
	// TODO un-hardcode batchDataPointer
	batchDataPointer := "https://storage.alignedlayer.com/b4b654a31b43c7b5711206eea7d44f884ece1fe7164b478fa16215be77dc84cb.json"

	var proofFile, pubInputFile, verificationKeyFile string

	provingSystem, err := ParseProvingSystem(c.String(provingSystemFlag.Name))
	if err != nil {
		return [32]byte{}, "", err
	}

	if x == 0 { //previous version, not generated by infinite-generator read proof from flag parameters
		proofFile = c.String(proofFlag.Name)
		pubInputFile = c.String(publicInputFlag.Name)
		verificationKeyFile = c.String(verificationKeyFlag.Name)
	} else { //new version, generated by infinite-generator, we can calculate the real values
		outputDir := "task_sender/test_examples/gnark_groth16_bn254_infinite_script/infinite_proofs/"
		proofFile = outputDir + "ineq_" + strconv.Itoa(x) + "_groth16.proof" //TODO un-hardcode provingSystem
		pubInputFile = outputDir + "ineq_" + strconv.Itoa(x) + "_groth16.pub"
		verificationKeyFile = outputDir + "ineq_" + strconv.Itoa(x) + "_groth16.vk"
	}
	ProofByteArray, err := os.ReadFile(proofFile)
	if err != nil {
		return [32]byte{}, "", err
	}
	PubInputByteArray, err := os.ReadFile(pubInputFile)
	if err != nil {
		return [32]byte{}, "", err
	}
	VerificationKeyByteArray, err := os.ReadFile(verificationKeyFile)
	if err != nil {
		return [32]byte{}, "", err
	}

	var data operator.VerificationData
	if provingSystem == common.SP1 { // TODO is this the correct way of handling VerificationKey/VmProgramCode ?
		data = operator.VerificationData{
			ProvingSystemId: provingSystem,
			Proof:           ProofByteArray,
			PubInput:        PubInputByteArray,
			VerificationKey: []byte(""),
			VmProgramCode:   VerificationKeyByteArray,
		}
	} else {
		data = operator.VerificationData{
			ProvingSystemId: provingSystem,
			Proof:           ProofByteArray,
			PubInput:        PubInputByteArray,
			VerificationKey: VerificationKeyByteArray,
			VmProgramCode:   []byte(""),
		}
	}

	byteArray, err := json.Marshal(data)
	if err != nil {
		return [32]byte{}, "", err
	}
	merkleRoot := sha256.Sum256(byteArray)

	return merkleRoot, batchDataPointer, nil
}

func taskSenderLoopMain(c *cli.Context) error {
	interval := c.Int(intervalFlag.Name)

	if interval < 1 {
		return fmt.Errorf("interval must be greater than 0")
	}

	for {
		err := taskSenderMain(c)
		if err != nil {
			return err
		}
		time.Sleep(time.Duration(interval) * time.Second)
	}
}

func taskSenderInfiniteMain(c *cli.Context) error {
	interval := c.Int(intervalFlag.Name)

	if interval < 1 {
		return fmt.Errorf("interval must be greater than 0")
	}

	x := 0
	for {
		x += 1
		generateproof.GenerateIneqProof(x)
		err := taskSenderMain(c, x)
		if err != nil {
			return err
		}
		time.Sleep(time.Duration(interval) * time.Second)
	}
}

func ParseProvingSystem(provingSystemStr string) (common.ProvingSystemId, error) {
	provingSystemStr = strings.TrimSpace(provingSystemStr)
	switch provingSystemStr {
	case "plonk_bls12_381":
		return common.GnarkPlonkBls12_381, nil
	case "plonk_bn254":
		return common.GnarkPlonkBn254, nil
	case "groth16_bn254":
		return common.Groth16Bn254, nil
	case "sp1":
		return common.SP1, nil
	default:
		var unknownValue common.ProvingSystemId
		return unknownValue, fmt.Errorf("unsupported proving system: %s", provingSystemStr)
	}
}
